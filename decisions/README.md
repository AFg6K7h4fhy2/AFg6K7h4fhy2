# Decision Making Across Technical Activities

This README attempts to collect some of the author's reasons for making certain decisions with respect to the author's work.

Reasoning processes might consist of outlining pros and cons of different approaches to some task (e.g. including the structure of repository the author has worked on using `tree`). Decisions might include answers to questions of How Much, Whether To, and Which Way that arise in the author's work. The author's work includes computational modelling, writing research manuscripts, and creating software packages.

The `decisions` folder exists, with its decisions and decision-explanations, so that the author may direct others, who might be considering their options on the same or similar decisions or who might be curious as to why the author has made some decision, to this folder.

The author very much expects that their decisions, decision-making processes, and the organization and framing of their `decisions` folder will change with time.

## Folder Structure

```
.
├── DECISION_MAKING_README.md
├── archiving.md
├── automation.md
├── branch_protection.md
├── changelogs.md
├── citations.md
├── code_complexity.md
├── code_quality.md
├── code_review.md
├── codeowners.md
├── commit_messages.md
├── commit_size.md
├── contacting.md
├── containers.md
├── contributions.md
├── daily_tasks.md
├── data_inclusion.md
├── data_vintaging.md
├── databases.md
├── diagrams.md
├── discussions.md
├── documentation.md
├── documents.md
├── envs.md
├── gitignoring.md
├── goals.md
├── graph_scales.md
├── knowledge_maps.md
├── linguistic_complexity.md
├── llms.md
├── makefiles.md
├── measurement.md
├── memory.md
├── naming_conventions.md
├── naming_directories.md
├── notation.md
├── on_off_github.md
├── pandoc.md
├── poetry.md
├── precommit.md
├── problem_solving.md
├── projects.md
├── proofs.md
├── purpose.md
├── python_bayesian.md
├── python_configs.md
├── python_docstrings.md
├── python_environment.md
├── python_header.md
├── python_jax.md
├── python_linting.md
├── python_logging.md
├── python_mocking.md
├── python_notebooks.md
├── python_plotting.md
├── python_testing.md
├── python_typing.md
├── readmes.md
├── repo_decals.md
├── repo_issues.md
├── repo_labels.md
├── repo_licensing.md
├── repo_milestones.md
├── repo_productivity.md
├── repo_security.md
├── repo_templating.md
├── repo_topics.md
├── reproducibility.md
├── runtime.md
├── security.md
└── templates.md

1 directory, 71 files
```

## Decisions Under Consideration


* Repository README
* READMEs for individual folders
* Naming at different levels of the directory
* Python Virtual Environments
* Getting Feedback
* Virality
* Privacy
* Repository Tags
* Repository Discussions
* Issue Labels
* Issue Templates
  * Bug
  * AnyIssue
* Issue Creation Norms
* Common Issues
* Changelog
* Contributing
* Code Reviews (PRs)
* Tagging People
* Asking Other People QUestions (only after X time has been spent doing this).
* Commit Messages
* Website Building
  * Quarto
  * Jekyll
* Citations
  * Personal Writing
  * Repositories
* Licenses
* Repository Types
* Repository Templating (Build As Though Others USe)
  * Research / Writing Repository
  * Modelling Repository
  * Python Package Repository
* Personal Repository Content
  * Goals
  * Ideas
* Mathematical Notation (latex you use and what you mean)
* Package Versioning
* Python Package Building
* Rules Of Engagement
  * Crocker's Rules
* Forecast Scoring
*


More Detail Needed:

* Stan
* PEPs
* NumPyro Docs
* JAX Docs
* Podman
* OpenScienceFoundation
* GitHub Docs




<!-- * Archiving: How should we be archiving data, commits, authorships, decisions, output, etc... beyond version control?
* Automation: What can be automated here? How much automation should be done outside of GitHub Actions?
* Branch Protection: When shouldn't this be the default? How much protection makes sense?
* Changelogs: How should we do changelogs?
* Citations: What should be people's behavior when citing a repository, file, page, etc... that we've created?
* Code Complexity: What tools should we employ for measuring code complexity?
* Code Quality: What tools should we employ for measuring code quality?
* Coed Review: What standards should we have around reviewing other people's code?
* Codeowners: What standards should we have for the content of Codeowners files? -->
